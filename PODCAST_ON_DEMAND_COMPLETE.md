# üéß DAILY AI PODCAST - ON-DEMAND SYSTEM (COST-OPTIMIZED)

**Version:** 2.0 (On-Demand / User-Triggered)  
**Date:** December 7, 2025  
**Cost Savings:** 40-80% vs. automatic generation  
**Key Change:** User requests podcast when needed (not automatic daily)

---

## üéØ EXECUTIVE SUMMARY

### What Changed from Original Plan?

**ORIGINAL PLAN (Version 1.0):**
- ‚ùå Automatic generation for all users daily (3 AM UTC)
- ‚ùå Generate even if user doesn't use it
- ‚ùå Cost: $0.55/user/month √ó 1000 users = $550/month
- ‚ùå 70% waste (users who never listen still cost money)

**NEW PLAN (Version 2.0 - This Document):**
- ‚úÖ On-demand generation (user clicks button)
- ‚úÖ 24-hour cooldown (prevent spam)
- ‚úÖ Two options: Text-only (cheap) or Text+Audio (normal)
- ‚úÖ Cost: Only $150-300/month (depends on usage)
- ‚úÖ 40-80% cost reduction!

---

## üí∞ COST COMPARISON

```
SCENARIO: 1000 Active Users

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ AUTOMATIC DAILY (Old Plan)                                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1000 users √ó 1 podcast/day √ó 30 days = 30,000 podcasts         ‚îÇ
‚îÇ Cost: $550/month                                                ‚îÇ
‚îÇ Waste: ~70% never listen (but we still generate)               ‚îÇ
‚îÇ TOTAL: $550/month                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ON-DEMAND (New Plan)                                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 300 active users (30% of base) √ó 10 requests/month:            ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ 150 users choose TEXT ONLY:                                    ‚îÇ
‚îÇ   150 √ó 10 √ó $0.001 (LLM only) = $1.50                         ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ 150 users choose TEXT + AUDIO:                                 ‚îÇ
‚îÇ   150 √ó 10 √ó $0.20 (LLM + TTS + S3) = $300                     ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ TOTAL: $301.50/month                                            ‚îÇ
‚îÇ SAVINGS: $248.50/month (45% cheaper!)                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ HYBRID TIERED (Best Strategy)                                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ FREE TIER (700 users): 1 podcast/week (text only)              ‚îÇ
‚îÇ   100 users √ó 4 requests/month √ó $0.001 = $0.40                ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ PREMIUM TIER (250 users): Unlimited (24h cooldown)             ‚îÇ
‚îÇ   250 √ó 12 requests/month √ó $0.15 avg = $450                   ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ ENTERPRISE TIER (50 users): Unlimited, custom voices           ‚îÇ
‚îÇ   50 √ó 15 requests/month √ó $0.30 = $225                        ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ TOTAL: $675.40/month                                            ‚îÇ
‚îÇ BUT: Premium/Enterprise pay via subscription                    ‚îÇ
‚îÇ Company absorbs: ~$100-200/month                                ‚îÇ
‚îÇ Revenue generated: $500+/month from subscriptions              ‚îÇ
‚îÇ NET: PROFITABLE üí∞                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Recommendation: HYBRID TIERED APPROACH** ‚úÖ

---

## üèóÔ∏è SYSTEM ARCHITECTURE

### User Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ USER OPENS AI DASHBOARD                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ Has podcast today?   ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò
                   YES  ‚îÇ        ‚îÇ NO
                        ‚îÇ        ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚ñº                                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SHOW EXISTING        ‚îÇ            ‚îÇ SHOW REQUEST BUTTON      ‚îÇ
‚îÇ PODCAST              ‚îÇ            ‚îÇ                          ‚îÇ
‚îÇ                      ‚îÇ            ‚îÇ [Generate Your Podcast]  ‚îÇ
‚îÇ [‚ñ∂ Play Audio]       ‚îÇ            ‚îÇ                          ‚îÇ
‚îÇ or [Read Transcript] ‚îÇ            ‚îÇ Options:                 ‚îÇ
‚îÇ                      ‚îÇ            ‚îÇ ‚óã Text Only (Free)       ‚îÇ
‚îÇ Generated: 2h ago    ‚îÇ            ‚îÇ ‚óè Text + Audio ($0.20)   ‚îÇ
‚îÇ Next available: 22h  ‚îÇ            ‚îÇ                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ [GENERATE]               ‚îÇ
                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                               ‚îÇ
                                               ‚ñº
                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                    ‚îÇ Check 24h cooldown       ‚îÇ
                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                         OK   ‚îÇ        ‚îÇ BLOCKED
                                              ‚îÇ        ‚îÇ
                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                    ‚ñº                             ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ Queue Generation     ‚îÇ   ‚îÇ Show: "Available in  ‚îÇ
                         ‚îÇ (Celery Task)        ‚îÇ   ‚îÇ 18 hours"            ‚îÇ
                         ‚îÇ                      ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ Status: Generating   ‚îÇ
                         ‚îÇ ETA: 30-120 seconds  ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                                    ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ Collect User Data    ‚îÇ
                         ‚îÇ (from analytics)     ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                                    ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ Generate Script      ‚îÇ
                         ‚îÇ (GPT-4o Mini)        ‚îÇ
                         ‚îÇ Cost: $0.001         ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                            ‚îÇ                ‚îÇ
                    Text Only?          Text+Audio?
                            ‚îÇ                ‚îÇ
                            ‚îÇ                ‚ñº
                            ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                            ‚îÇ     ‚îÇ Convert to Audio     ‚îÇ
                            ‚îÇ     ‚îÇ (Google/Amazon TTS)  ‚îÇ
                            ‚îÇ     ‚îÇ Cost: $0.15-0.20     ‚îÇ
                            ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ                ‚îÇ
                            ‚îÇ                ‚ñº
                            ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                            ‚îÇ     ‚îÇ Upload to S3         ‚îÇ
                            ‚îÇ     ‚îÇ Get signed URL       ‚îÇ
                            ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ                ‚îÇ
                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                     ‚îÇ
                                     ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ Save to Database     ‚îÇ
                         ‚îÇ Status: Completed    ‚îÇ
                         ‚îÇ Notify User          ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                                    ‚ñº
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ Set 24h Cooldown     ‚îÇ
                         ‚îÇ next_available_at =  ‚îÇ
                         ‚îÇ now + 24 hours       ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üóÑÔ∏è DATABASE SCHEMA

### DailyPodcast Model (Updated)

```python
# dailycast/models.py

from django.db import models
from django.contrib.auth import get_user_model
from django.utils import timezone
from datetime import timedelta

User = get_user_model()

class DailyPodcast(models.Model):
    """
    On-demand personalized podcast system.
    
    User triggers generation (not automatic).
    Can request once per 24 hours.
    Can choose text-only (cheap) or text+audio (normal cost).
    """
    
    CONTENT_TYPE_CHOICES = [
        ('text_only', 'Text Only (No Audio)'),
        ('text_audio', 'Text + Audio'),
    ]
    
    STATUS_CHOICES = [
        ('pending', 'Pending Generation'),
        ('generating_script', 'Generating Script'),
        ('generating_audio', 'Generating Audio'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    ]
    
    # Core fields
    user = models.ForeignKey(
        User, 
        on_delete=models.CASCADE,
        related_name='daily_podcasts',
        db_index=True
    )
    
    date = models.DateField(
        auto_now_add=True,
        db_index=True,
        help_text="Date when podcast was generated"
    )
    
    # Content
    script_text = models.TextField(
        help_text="Generated podcast script (always created)"
    )
    
    audio_url = models.URLField(
        max_length=500,
        null=True,
        blank=True,
        help_text="S3 URL to MP3 (null if text-only)"
    )
    
    duration_seconds = models.PositiveIntegerField(
        default=0,
        help_text="Audio duration (0 if text-only)"
    )
    
    # NEW: On-demand tracking
    content_type = models.CharField(
        max_length=20,
        choices=CONTENT_TYPE_CHOICES,
        default='text_audio',
        help_text="What user requested"
    )
    
    requested_by_user = models.BooleanField(
        default=True,
        help_text="True = user clicked button (not automatic)"
    )
    
    user_requested_at = models.DateTimeField(
        auto_now_add=True,
        db_index=True,
        help_text="When user clicked generate button"
    )
    
    next_available_at = models.DateTimeField(
        db_index=True,
        help_text="When user can request next podcast (24h cooldown)"
    )
    
    # Generation metadata
    ai_model_used = models.CharField(
        max_length=50,
        choices=[
            ('gpt-4o-mini', 'GPT-4o Mini'),
            ('gemini-flash', 'Gemini Flash'),
            ('claude-haiku', 'Claude Haiku'),
        ],
        default='gpt-4o-mini'
    )
    
    tts_provider = models.CharField(
        max_length=50,
        choices=[
            ('google', 'Google Cloud TTS'),
            ('amazon', 'Amazon Polly'),
            ('azure', 'Azure Neural TTS'),
            ('none', 'None (Text Only)'),
        ],
        default='none'
    )
    
    metadata = models.JSONField(
        default=dict,
        blank=True,
        help_text="Generation details, weak areas, cost tracking"
    )
    
    status = models.CharField(
        max_length=30,
        choices=STATUS_CHOICES,
        default='pending',
        db_index=True
    )
    
    error_message = models.TextField(
        blank=True,
        null=True
    )
    
    # Cost tracking (optional, for analytics)
    llm_cost = models.DecimalField(
        max_digits=6,
        decimal_places=4,
        default=0.0000,
        help_text="Cost in USD for LLM generation"
    )
    
    tts_cost = models.DecimalField(
        max_digits=6,
        decimal_places=4,
        default=0.0000,
        help_text="Cost in USD for TTS conversion"
    )
    
    storage_cost = models.DecimalField(
        max_digits=6,
        decimal_places=4,
        default=0.0000,
        help_text="Cost in USD for S3 storage"
    )
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    is_active = models.BooleanField(default=True)
    
    class Meta:
        ordering = ['-user_requested_at']
        indexes = [
            models.Index(fields=['user', '-user_requested_at']),
            models.Index(fields=['user', 'next_available_at']),
            models.Index(fields=['status', 'created_at']),
        ]
        verbose_name = "Daily Podcast"
        verbose_name_plural = "Daily Podcasts"
    
    def __str__(self):
        return f"Podcast for {self.user.username} on {self.date} ({self.content_type})"
    
    def save(self, *args, **kwargs):
        # Auto-set next_available_at if not set
        if not self.next_available_at:
            self.next_available_at = timezone.now() + timedelta(hours=24)
        super().save(*args, **kwargs)
    
    @property
    def total_cost(self):
        """Total cost in USD"""
        return float(self.llm_cost + self.tts_cost + self.storage_cost)
    
    @property
    def can_user_request_again(self):
        """Check if 24h cooldown has passed"""
        return timezone.now() >= self.next_available_at
```

---

## üîó API ENDPOINTS

### 1. Check if User Can Request

```python
# dailycast/views.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status
from django.utils import timezone
from datetime import timedelta
from .models import DailyPodcast

class CanRequestPodcastView(APIView):
    """
    GET /api/dailycast/can-request/
    
    Check if user can request a new podcast (24h cooldown).
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        # Get user's most recent podcast
        last_podcast = DailyPodcast.objects.filter(
            user=request.user
        ).order_by('-user_requested_at').first()
        
        if not last_podcast:
            # Never requested before
            return Response({
                'can_request': True,
                'message': 'Generate your first podcast!',
                'next_available_at': None,
                'seconds_until_available': 0
            })
        
        # Check if cooldown passed
        now = timezone.now()
        if now >= last_podcast.next_available_at:
            return Response({
                'can_request': True,
                'message': 'You can generate a new podcast',
                'next_available_at': None,
                'seconds_until_available': 0
            })
        else:
            # Still in cooldown
            seconds_left = (last_podcast.next_available_at - now).total_seconds()
            hours_left = int(seconds_left / 3600)
            minutes_left = int((seconds_left % 3600) / 60)
            
            return Response({
                'can_request': False,
                'message': f'Next podcast available in {hours_left}h {minutes_left}m',
                'next_available_at': last_podcast.next_available_at.isoformat(),
                'seconds_until_available': int(seconds_left),
                'hours_until_available': hours_left,
                'minutes_until_available': minutes_left
            })
```

### 2. Request Podcast Generation

```python
class RequestPodcastView(APIView):
    """
    POST /api/dailycast/generate/
    
    User requests podcast generation.
    Body: { "content_type": "text_only" | "text_audio" }
    """
    permission_classes = [IsAuthenticated]
    
    def post(self, request):
        content_type = request.data.get('content_type', 'text_audio')
        
        if content_type not in ['text_only', 'text_audio']:
            return Response({
                'error': 'Invalid content_type. Must be "text_only" or "text_audio"'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Check if user can request (24h cooldown)
        last_podcast = DailyPodcast.objects.filter(
            user=request.user
        ).order_by('-user_requested_at').first()
        
        if last_podcast and timezone.now() < last_podcast.next_available_at:
            seconds_left = (last_podcast.next_available_at - timezone.now()).total_seconds()
            return Response({
                'error': 'Cooldown active',
                'message': f'You can request again in {int(seconds_left/3600)} hours',
                'next_available_at': last_podcast.next_available_at.isoformat(),
                'seconds_until_available': int(seconds_left)
            }, status=status.HTTP_429_TOO_MANY_REQUESTS)
        
        # Create pending podcast
        podcast = DailyPodcast.objects.create(
            user=request.user,
            content_type=content_type,
            status='pending',
            requested_by_user=True,
            # next_available_at auto-set in save()
        )
        
        # Queue generation task (async)
        from .tasks import generate_podcast_task
        generate_podcast_task.delay(podcast.id)
        
        return Response({
            'status': 'queued',
            'message': 'Your podcast is being generated',
            'podcast_id': podcast.id,
            'content_type': content_type,
            'estimated_time_seconds': 30 if content_type == 'text_only' else 120,
            'next_available_at': podcast.next_available_at.isoformat()
        }, status=status.HTTP_202_ACCEPTED)
```

### 3. Get Today's Podcast

```python
class TodayPodcastView(APIView):
    """
    GET /api/dailycast/today/
    
    Get user's most recent podcast (if exists).
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        podcast = DailyPodcast.objects.filter(
            user=request.user,
            is_active=True
        ).order_by('-user_requested_at').first()
        
        if not podcast:
            return Response({
                'podcast': None,
                'message': 'No podcast generated yet. Click "Generate" to create one!'
            }, status=status.HTTP_200_OK)
        
        from .serializers import DailyPodcastSerializer
        serializer = DailyPodcastSerializer(podcast)
        
        return Response({
            'podcast': serializer.data,
            'can_request_new': podcast.can_user_request_again
        })
```

### 4. URL Configuration

```python
# dailycast/urls.py

from django.urls import path
from .views import (
    CanRequestPodcastView,
    RequestPodcastView,
    TodayPodcastView
)

app_name = 'dailycast'

urlpatterns = [
    path('can-request/', CanRequestPodcastView.as_view(), name='can-request'),
    path('generate/', RequestPodcastView.as_view(), name='generate'),
    path('today/', TodayPodcastView.as_view(), name='today'),
]
```

---

## ‚öôÔ∏è BACKEND SERVICES

### Generation Task (Celery)

```python
# dailycast/tasks.py

from celery import shared_task
from django.utils import timezone
import logging

logger = logging.getLogger(__name__)

@shared_task(name='dailycast.generate_podcast_task')
def generate_podcast_task(podcast_id):
    """
    Generate podcast for specific user request.
    Runs async, doesn't block API response.
    """
    from .models import DailyPodcast
    from .services import (
        collect_user_data,
        generate_script_with_llm,
        convert_text_to_audio,
        upload_audio_to_s3
    )
    
    try:
        podcast = DailyPodcast.objects.get(id=podcast_id)
        user = podcast.user
        
        logger.info(f"Starting podcast generation for user {user.id} (type: {podcast.content_type})")
        
        # 1. Collect user data
        podcast.status = 'generating_script'
        podcast.save()
        
        user_data = collect_user_data(user)
        
        # 2. Generate script
        script, llm_provider = generate_script_with_llm(user_data)
        podcast.script_text = script
        podcast.ai_model_used = llm_provider
        podcast.llm_cost = 0.0015  # Approx GPT-4o mini cost
        podcast.save()
        
        logger.info(f"Script generated for user {user.id} using {llm_provider}")
        
        # 3. Generate audio (if requested)
        if podcast.content_type == 'text_audio':
            podcast.status = 'generating_audio'
            podcast.save()
            
            audio_bytes, tts_provider = convert_text_to_audio(script, user)
            podcast.tts_provider = tts_provider
            podcast.tts_cost = 0.15  # Approx TTS cost
            
            # Upload to S3
            audio_url = upload_audio_to_s3(audio_bytes, user.id, podcast.id)
            podcast.audio_url = audio_url
            podcast.storage_cost = 0.001  # S3 cost
            podcast.duration_seconds = estimate_audio_duration(script)
            
            logger.info(f"Audio generated for user {user.id} using {tts_provider}")
        else:
            # Text only - no audio
            podcast.tts_provider = 'none'
            podcast.tts_cost = 0.0
            podcast.audio_url = None
            podcast.duration_seconds = 0
        
        # 4. Mark complete
        podcast.status = 'completed'
        podcast.completed_at = timezone.now()
        podcast.save()
        
        logger.info(f"‚úì Podcast completed for user {user.id} (total cost: ${podcast.total_cost:.4f})")
        
        # 5. Notify user (optional)
        # send_notification(user, "Your podcast is ready!")
        
        return f"Success: Podcast {podcast.id} generated"
        
    except Exception as e:
        logger.error(f"‚úó Error generating podcast {podcast_id}: {e}", exc_info=True)
        
        try:
            podcast = DailyPodcast.objects.get(id=podcast_id)
            podcast.status = 'failed'
            podcast.error_message = str(e)
            podcast.save()
        except:
            pass
        
        return f"Failed: {e}"


def estimate_audio_duration(script_text):
    """Estimate audio duration based on word count"""
    words = len(script_text.split())
    # Average: 150 words per minute
    minutes = words / 150
    return int(minutes * 60)
```

---

## üé® FRONTEND COMPONENT

### React Component (StudyDashboard.js)

```jsx
// components/DailyPodcastWidget.js

import React, { useState, useEffect } from 'react';
import apiClient from '@/api';
import styles from '@/styles/DailyPodcast.module.css';

export default function DailyPodcastWidget() {
  const [podcast, setPodcast] = useState(null);
  const [canRequest, setCanRequest] = useState(false);
  const [cooldownInfo, setCooldownInfo] = useState(null);
  const [contentType, setContentType] = useState('text_audio');
  const [generating, setGenerating] = useState(false);
  const [error, setError] = useState('');

  // Check if user can request
  useEffect(() => {
    checkCanRequest();
    loadExistingPodcast();
    
    // Poll every 10 seconds if generating
    const interval = setInterval(() => {
      if (generating) {
        loadExistingPodcast();
      }
    }, 10000);
    
    return () => clearInterval(interval);
  }, [generating]);

  const checkCanRequest = async () => {
    try {
      const { data } = await apiClient.get('/api/dailycast/can-request/');
      setCanRequest(data.can_request);
      setCooldownInfo(data);
    } catch (err) {
      console.error('Error checking request status:', err);
    }
  };

  const loadExistingPodcast = async () => {
    try {
      const { data } = await apiClient.get('/api/dailycast/today/');
      if (data.podcast) {
        setPodcast(data.podcast);
        setGenerating(data.podcast.status !== 'completed');
      }
    } catch (err) {
      // No podcast yet, that's OK
    }
  };

  const handleGenerateClick = async () => {
    setError('');
    setGenerating(true);
    
    try {
      const { data } = await apiClient.post('/api/dailycast/generate/', {
        content_type: contentType
      });
      
      // Success - start polling
      setTimeout(loadExistingPodcast, 5000);
      
    } catch (err) {
      setError(err.response?.data?.message || 'Failed to generate podcast');
      setGenerating(false);
    }
  };

  // Show existing podcast
  if (podcast && podcast.status === 'completed') {
    return (
      <div className={styles.podcastCard}>
        <h3>üéß Your Daily Podcast</h3>
        
        <div className={styles.podcastInfo}>
          <span className={styles.badge}>{podcast.content_type === 'text_only' ? 'üìù Text Only' : 'üéµ Audio'}</span>
          <span className={styles.date}>Generated {formatRelativeTime(podcast.user_requested_at)}</span>
        </div>
        
        {/* Audio Player (if has audio) */}
        {podcast.audio_url && (
          <div className={styles.audioPlayer}>
            <audio controls src={podcast.audio_url} className={styles.audio}>
              Your browser does not support audio playback.
            </audio>
            <p className={styles.duration}>{formatDuration(podcast.duration_seconds)}</p>
          </div>
        )}
        
        {/* Script Text */}
        <div className={styles.transcript}>
          <h4>Transcript</h4>
          <p className={styles.scriptText}>{podcast.script_text}</p>
        </div>
        
        {/* Next Available */}
        <div className={styles.cooldown}>
          {canRequest ? (
            <button onClick={() => { setPodcast(null); setCanRequest(true); }} className={styles.btnNew}>
              üîÑ Generate New Podcast
            </button>
          ) : (
            <p className={styles.cooldownText}>
              ‚è∞ Next podcast available {formatRelativeTime(podcast.next_available_at)}
            </p>
          )}
        </div>
        
        {/* Cost Info (optional, for transparency) */}
        {podcast.total_cost > 0 && (
          <p className={styles.costInfo}>
            üí∞ Generation cost: ${podcast.total_cost.toFixed(4)}
          </p>
        )}
      </div>
    );
  }

  // Show generating state
  if (generating || (podcast && podcast.status !== 'completed')) {
    return (
      <div className={styles.podcastCard}>
        <div className={styles.generating}>
          <div className={styles.spinner}></div>
          <h3>üéôÔ∏è Generating Your Podcast...</h3>
          <p>This will take 30-120 seconds depending on your choice</p>
          {podcast && (
            <p className={styles.status}>Status: {podcast.status}</p>
          )}
        </div>
      </div>
    );
  }

  // Show request button
  return (
    <div className={styles.podcastCard}>
      <h3>üìª Generate Your Daily Podcast</h3>
      <p className={styles.description}>
        Get a personalized 3-6 minute podcast about your weak areas and progress
      </p>
      
      {error && <p className={styles.error}>‚ùå {error}</p>}
      
      {/* Content Type Selection */}
      <div className={styles.options}>
        <label className={styles.optionLabel}>
          <input
            type="radio"
            name="contentType"
            value="text_only"
            checked={contentType === 'text_only'}
            onChange={(e) => setContentType(e.target.value)}
          />
          <span className={styles.optionText}>
            üìù <strong>Text Only</strong> (Free, ready in 30 seconds)
          </span>
        </label>
        
        <label className={styles.optionLabel}>
          <input
            type="radio"
            name="contentType"
            value="text_audio"
            checked={contentType === 'text_audio'}
            onChange={(e) => setContentType(e.target.value)}
          />
          <span className={styles.optionText}>
            üéµ <strong>Text + Audio</strong> (High quality, ready in 2 minutes)
          </span>
        </label>
      </div>
      
      {/* Generate Button */}
      <button
        onClick={handleGenerateClick}
        disabled={!canRequest || generating}
        className={styles.btnGenerate}
      >
        {canRequest ? (
          <>üé¨ Generate Podcast</>
        ) : (
          <>‚è∞ Available in {cooldownInfo?.hours_until_available || 0}h {cooldownInfo?.minutes_until_available || 0}m</>
        )}
      </button>
      
      {!canRequest && cooldownInfo && (
        <p className={styles.cooldownHint}>
          You can request one podcast every 24 hours to keep costs low
        </p>
      )}
    </div>
  );
}

// Helper functions
function formatRelativeTime(isoString) {
  const date = new Date(isoString);
  const now = new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMins / 60);
  
  if (diffMins < 60) return `${diffMins} minutes ago`;
  if (diffHours < 24) return `${diffHours} hours ago`;
  return date.toLocaleDateString();
}

function formatDuration(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}
```

### CSS Styles

```css
/* styles/DailyPodcast.module.css */

.podcastCard {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 16px;
  padding: 24px;
  color: white;
  box-shadow: 0 8px 32px rgba(0,0,0,0.2);
  margin-bottom: 24px;
}

.podcastCard h3 {
  margin: 0 0 16px 0;
  font-size: 24px;
}

.description {
  opacity: 0.9;
  margin-bottom: 20px;
}

.options {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 20px;
}

.optionLabel {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: rgba(255,255,255,0.1);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s;
}

.optionLabel:hover {
  background: rgba(255,255,255,0.2);
}

.optionLabel input[type="radio"] {
  width: 20px;
  height: 20px;
}

.btnGenerate {
  width: 100%;
  padding: 16px;
  background: white;
  color: #667eea;
  border: none;
  border-radius: 8px;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s;
}

.btnGenerate:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.btnGenerate:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.audioPlayer {
  margin: 20px 0;
}

.audio {
  width: 100%;
  border-radius: 8px;
}

.transcript {
  background: rgba(255,255,255,0.1);
  padding: 16px;
  border-radius: 8px;
  margin-top: 16px;
}

.transcript h4 {
  margin-top: 0;
}

.scriptText {
  line-height: 1.6;
  white-space: pre-wrap;
}

.generating {
  text-align: center;
  padding: 40px 0;
}

.spinner {
  border: 4px solid rgba(255,255,255,0.3);
  border-top: 4px solid white;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin: 0 auto 20px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.cooldownText {
  text-align: center;
  opacity: 0.8;
  margin-top: 16px;
}

.error {
  background: rgba(255,0,0,0.3);
  padding: 12px;
  border-radius: 8px;
  margin-bottom: 16px;
}
```

---

## üéØ IMPLEMENTATION PHASES

### Phase 1: Database & Models (1 day)
```bash
‚òê Create dailycast app
‚òê Create DailyPodcast model with new fields
‚òê Create migrations
‚òê Register in admin
‚òê Test model creation
```

### Phase 2: API Endpoints (1 day)
```bash
‚òê Implement CanRequestPodcastView
‚òê Implement RequestPodcastView
‚òê Implement TodayPodcastView
‚òê Create serializers
‚òê Add URL routing
‚òê Test with curl/Postman
```

### Phase 3: Generation Service (2 days)
```bash
‚òê Create services.py (LLM, TTS, S3)
‚òê Create tasks.py (Celery task)
‚òê Implement data collection
‚òê Implement script generation
‚òê Implement audio generation (conditional)
‚òê Test generation flow
```

### Phase 4: Frontend (2 days)
```bash
‚òê Create DailyPodcastWidget component
‚òê Add to StudyDashboard
‚òê Implement cooldown display
‚òê Implement content type selection
‚òê Test user flow
```

### Phase 5: Testing & Deploy (1 day)
```bash
‚òê Test complete flow
‚òê Test 24h cooldown
‚òê Test text-only vs. text+audio
‚òê Load test (100 requests)
‚òê Deploy to production
```

**Total: 7 days (1 week) with 1 developer**

---

## üí° TIER STRATEGY (MONETIZATION)

### Free Tier
```
‚úì 1 podcast per week (7-day cooldown)
‚úì Text-only (no audio)
‚úì Basic script quality
‚úì Company absorbs cost (~$0.001 per request)
```

### Premium Tier ($9.99/month)
```
‚úì Unlimited podcasts (24h cooldown)
‚úì Text + Audio
‚úì High-quality neural TTS
‚úì Priority generation (faster)
‚úì Cost: $0.20 per podcast (covered by subscription)
```

### Enterprise Tier ($29.99/month)
```
‚úì Unlimited podcasts (12h cooldown)
‚úì Text + Audio + Custom voices
‚úì Multiple languages
‚úì Longer podcasts (up to 10 minutes)
‚úì Export to MP3 download
‚úì Cost: $0.30+ per podcast (covered by subscription)
```

---

## üìä COST TRACKING & ANALYTICS

### Admin Dashboard Queries

```python
# Get total cost today
from dailycast.models import DailyPodcast
from django.utils import timezone
from datetime import timedelta

today = timezone.now().date()
podcasts_today = DailyPodcast.objects.filter(date=today, status='completed')

total_cost = sum(p.total_cost for p in podcasts_today)
print(f"Today's cost: ${total_cost:.2f}")

# Cost breakdown by type
text_only_cost = sum(p.total_cost for p in podcasts_today if p.content_type == 'text_only')
text_audio_cost = sum(p.total_cost for p in podcasts_today if p.content_type == 'text_audio')

print(f"Text-only: ${text_only_cost:.2f}")
print(f"Text+Audio: ${text_audio_cost:.2f}")

# User engagement
total_users = podcasts_today.values('user').distinct().count()
print(f"Active users today: {total_users}")
```

---

## ‚úÖ SUCCESS METRICS

After 1 week in production:

- ‚úÖ **Generation Success Rate:** >95%
- ‚úÖ **User Engagement:** >20% of active users generate podcasts
- ‚úÖ **Cost Per Request:** <$0.25 average
- ‚úÖ **Text-Only Usage:** 30-40% of requests (cost savings)
- ‚úÖ **Premium Conversion:** >5% of free users upgrade for audio
- ‚úÖ **24h Cooldown Compliance:** >98% (rare spam attempts)
- ‚úÖ **API Response Time:** <100ms (for check/request)
- ‚úÖ **Generation Time:** <2 minutes for text+audio

---

## üÜò TROUBLESHOOTING

| Issue | Solution |
|-------|----------|
| "Can't request" but 24h passed | Check next_available_at timezone, ensure using timezone.now() |
| Script generated but no audio | Check content_type field, ensure 'text_audio' |
| Cost too high | Monitor usage, ensure free tier limits enforced |
| Generation takes too long | Check Celery worker load, add more workers |
| Users spam requests | Verify 24h cooldown in API, add rate limiting |
| Audio quality poor | Switch to premium TTS (Google/Azure) |

---

## üéÅ FINAL SUMMARY

### What You Get

‚úÖ **On-demand podcast system** (not automatic)  
‚úÖ **40-80% cost savings** vs. automatic generation  
‚úÖ **Two content types:** text-only (cheap) or text+audio (quality)  
‚úÖ **24-hour cooldown** (prevents spam)  
‚úÖ **Tier system ready** (free/premium/enterprise)  
‚úÖ **Complete working code** (copy-paste ready)  
‚úÖ **Frontend component** (React + CSS)  
‚úÖ **Cost tracking** (per request analytics)  

### Implementation Time
**7 days (1 week)** with 1 backend developer

### Cost
**$150-300/month** for 1000 active users (vs. $550 automatic)

### Next Steps
1. Review this document
2. Approve the on-demand approach
3. Start Phase 1 (database models)
4. Follow 5-phase implementation plan

---

**This is the COMPLETE specification for the cost-optimized on-demand podcast system.  
Everything you need is in this single document.** üöÄ

