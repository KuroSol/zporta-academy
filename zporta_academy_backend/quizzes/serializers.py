# quizzes/serializers.py

from rest_framework import serializers
from django.db import transaction # Import transaction for atomic operations

# Assuming Subject/Course models live in separate apps:
from subjects.models import Subject # Import Subject from the 'subjects' app
from courses.models import Course   # Import Course from the 'courses' app
from .models import Quiz, Question, FillBlankQuestion, BlankWord, BlankSolution
from tags.models     import Tag
from tags.serializers import TagSerializer

# --- Serializers for Drag & Drop Nested Data ---
class BlankWordSerializer(serializers.ModelSerializer):
    class Meta:
        model = BlankWord
        fields = ['id', 'text']

class BlankSolutionSerializer(serializers.ModelSerializer):
    # Make correct_word writable by accepting the ID of a BlankWord
    correct_word = serializers.PrimaryKeyRelatedField(queryset=BlankWord.objects.all())

    class Meta:
        model = BlankSolution
        fields = ['slot_index', 'correct_word']

class FillBlankSerializer(serializers.ModelSerializer):
    # These are read-only representations for output when reading a FillBlankQuestion
    words     = BlankWordSerializer(many=True, read_only=True)
    solutions = BlankSolutionSerializer(many=True, read_only=True) # Uses the above BlankSolutionSerializer

    class Meta:
        model  = FillBlankQuestion
        # Defines fields for reading the nested structure of a FillBlankQuestion
        fields = ['id', 'sentence', 'words', 'solutions']
        read_only_fields = ['id', 'words', 'solutions'] # Sentence can be part of input if needed

# --- Main Question Serializer ---
class QuestionSerializer(serializers.ModelSerializer):
    # Explicitly define fields that are conditionally required as not required here
    option1 = serializers.CharField(required=False, allow_blank=True, allow_null=True)
    option2 = serializers.CharField(required=False, allow_blank=True, allow_null=True)
    option3 = serializers.CharField(required=False, allow_blank=True, allow_null=True)
    option4 = serializers.CharField(required=False, allow_blank=True, allow_null=True)

    correct_option = serializers.IntegerField(required=False, allow_null=True) # For MCQ
    correct_options = serializers.JSONField(required=False, allow_null=True) # For Multi, Sort solution
    correct_answer = serializers.CharField(required=False, allow_blank=True, allow_null=True) # For Short Answer
    question_data = serializers.JSONField(required=False, allow_null=True) # For Sort items/zones

    # Media fields
    question_image = serializers.ImageField(required=False, allow_null=True, use_url=True)
    question_audio = serializers.FileField(required=False, allow_null=True, use_url=True)
    option1_image = serializers.ImageField(required=False, allow_null=True, use_url=True)
    option1_audio = serializers.FileField(required=False, allow_null=True, use_url=True)
    option2_image = serializers.ImageField(required=False, allow_null=True, use_url=True)
    option2_audio = serializers.FileField(required=False, allow_null=True, use_url=True)
    option3_image = serializers.ImageField(required=False, allow_null=True, use_url=True)
    option3_audio = serializers.FileField(required=False, allow_null=True, use_url=True)
    option4_image = serializers.ImageField(required=False, allow_null=True, use_url=True)
    option4_audio = serializers.FileField(required=False, allow_null=True, use_url=True)

    # --- Drag & Drop Handling ---
    # 'fill_blank' is for *incoming* JSON data when creating/updating dragdrop questions
    fill_blank = serializers.JSONField(write_only=True, required=False, allow_null=True)
    # '_fill_blank' is for *outgoing* nested representation using FillBlankSerializer
    # It sources its data from the 'fill_blank' OneToOneField on the Question model
    _fill_blank = FillBlankSerializer(source='fill_blank', read_only=True)

    # Read-only alt text fields (auto-generated by model's save method)
    question_image_alt = serializers.CharField(read_only=True)
    option1_image_alt = serializers.CharField(read_only=True)
    option2_image_alt = serializers.CharField(read_only=True)
    option3_image_alt = serializers.CharField(read_only=True)
    option4_image_alt = serializers.CharField(read_only=True)

    # Add temp_id for frontend mapping; it's write_only and not saved to the Question model directly.
    temp_id = serializers.CharField(write_only=True, required=False, allow_null=True)

    class Meta:
        model = Question
        fields = [
            'id', 'quiz', 'temp_id', # Added temp_id for processing
            'question_type',
            'question_text',
            'question_image', 'question_image_alt', 'question_audio',
            'allow_speech_to_text',

            # Options
            'option1', 'option1_image', 'option1_image_alt', 'option1_audio',
            'option2', 'option2_image', 'option2_image_alt', 'option2_audio',
            'option3', 'option3_image', 'option3_image_alt', 'option3_audio',
            'option4', 'option4_image', 'option4_image_alt', 'option4_audio',

            # Answers / Data based on question type
            'correct_option',  # For MCQ
            'correct_options', # For Multi-Select (list of option numbers), Sort (list of ordered strings)
            'correct_answer',  # For Short Answer
            'question_data',   # For Sort items (list of strings to be sorted)
            'fill_blank',      # Incoming JSON blob for dragdrop (write-only)
            '_fill_blank',     # Outgoing nested object for dragdrop (read-only, represents FillBlankQuestion)
            # Hints
            'hint1', 'hint2',
        ]
        # 'quiz' is typically set by the parent QuizSerializer.
        # '_fill_blank' is read-only as it's a representation of related models.
        # Alt text fields are generated by the model.
        read_only_fields = [
            'id', 'quiz', '_fill_blank',
            'question_image_alt', 'option1_image_alt', 'option2_image_alt',
            'option3_image_alt', 'option4_image_alt',
        ]

    def validate(self, data):
        """
        Perform validation based on question_type.
        'data' contains the fields submitted for this specific question.
        'self.instance' is the existing question object if this is an update.
        """
        question_type = data.get('question_type', getattr(self.instance, 'question_type', None))
        if not question_type:
             raise serializers.ValidationError({"question_type": "Question type is required."})

        errors = {} # Accumulate errors

        # --- Validation for MCQ (Single Correct Choice) ---
        if question_type == 'mcq':
            if not data.get('option1'): errors['option1'] = 'Option 1 text is required for MCQ.'
            if not data.get('option2'): errors['option2'] = 'Option 2 text is required for MCQ.'
            correct_option = data.get('correct_option')
            if correct_option is None:
                 errors['correct_option'] = 'A correct option (1-4) must be selected for MCQ.'
            elif not isinstance(correct_option, int) or correct_option not in [1, 2, 3, 4]:
                 errors['correct_option'] = 'Correct option must be 1, 2, 3, or 4.'
            elif not data.get(f"option{correct_option}"): # Check if selected option has text
                 errors.setdefault('correct_option', []).append(
                     f"The selected correct option ({correct_option}) does not have any text."
                 )

        # --- Validation for Multi (Multiple Correct Choices) ---
        elif question_type == 'multi':
            if not data.get('option1'): errors['option1'] = 'Option 1 text is required for Multi-Select.'
            if not data.get('option2'): errors['option2'] = 'Option 2 text is required for Multi-Select.'
            correct_options = data.get('correct_options') # Expects a list of numbers, e.g., [1, 3]
            if not correct_options or not isinstance(correct_options, list) or len(correct_options) == 0:
                errors['correct_options'] = 'At least one correct option must be selected as a list (e.g., [1, 3]) for Multi-Select.'
            else:
                invalid_options = []
                for opt_num in correct_options:
                    if not isinstance(opt_num, int) or opt_num not in [1, 2, 3, 4]:
                        invalid_options.append(f"Invalid option number: {opt_num}. Must be 1-4.")
                    elif not data.get(f"option{opt_num}"): # Check if selected option has text
                        invalid_options.append(f"Selected correct option {opt_num} does not have any text.")
                if invalid_options:
                     errors['correct_options'] = invalid_options

        # --- Validation for Short Answer ---
        elif question_type == 'short':
            allow_speech = data.get('allow_speech_to_text', getattr(self.instance, 'allow_speech_to_text', False))
            if not data.get('correct_answer') and not allow_speech:
                 errors['correct_answer'] = 'A correct text answer is required for Short Answer questions unless speech input is enabled.'

        # --- Validation for Word Sort ---
        elif question_type == 'sort':
             q_data = data.get('question_data', {}) # Expects {'items': ['word1', 'word2', ...]}
             items = q_data.get('items', []) if isinstance(q_data, dict) else []
             if not isinstance(items, list) or len(items) < 2:
                  errors.setdefault('question_data', {})['items'] = "At least two sortable 'items' (words/phrases) are required for Word Sort."
             
             # Solution for sort is stored in correct_options (list of strings in correct order)
             correct_opts_sort = data.get('correct_options')
             if not correct_opts_sort or not isinstance(correct_opts_sort, list):
                 errors['correct_options'] = "A correct order (list of strings) must be provided for Word Sort."
             elif len(correct_opts_sort) != len(items):
                 errors['correct_options'] = "The correct order list must contain the same number of items as 'question_data.items'."
             elif any(not isinstance(item, str) for item in correct_opts_sort):
                 errors['correct_options'] = "Correct order for Word Sort must be a list of strings."
             # Ensure all items in correct_options are present in question_data.items
             elif set(correct_opts_sort) != set(items):
                 errors['correct_options'] = "All items in the correct order must match the items defined in 'question_data.items'."


        # --- Validation for Drag and Drop ---
        elif question_type == 'dragdrop':
            fill_data = data.get('fill_blank') # Check the incoming JSON blob
            if not fill_data:
                errors['fill_blank'] = "fill_blank data (sentence, words, solutions) is required for Drag & Drop questions."
            elif not isinstance(fill_data, dict):
                errors['fill_blank'] = "fill_blank data must be a JSON object."
            else:
                sentence = fill_data.get('sentence')
                words_data = fill_data.get('words') # Expects [{'text': 'word1'}, {'text': 'word2'}]
                solutions_data = fill_data.get('solutions') # Expects [{'slot_index': 0, 'correct_word': 'item_tempId_0'}]

                if not sentence or not isinstance(sentence, str) or '*' not in sentence:
                    errors.setdefault('fill_blank', {})['sentence'] = "A sentence string with at least one '*' placeholder is required."
                
                if not words_data or not isinstance(words_data, list) or len(words_data) == 0:
                    errors.setdefault('fill_blank', {})['words'] = "At least one word object (e.g., {'text': 'word'}) is required in the 'words' list."
                else:
                    for idx, w_obj in enumerate(words_data):
                        if not isinstance(w_obj, dict) or 'text' not in w_obj or not w_obj['text']:
                             errors.setdefault('fill_blank', {}).setdefault('words', []).append(f"Word at index {idx} must be an object with a non-empty 'text' key.")

                if not solutions_data or not isinstance(solutions_data, list):
                     errors.setdefault('fill_blank', {})['solutions'] = "The 'solutions' list is required."
                else:
                    blank_count = sentence.count('*') if sentence and isinstance(sentence, str) else 0
                    if len(solutions_data) != blank_count:
                        errors.setdefault('fill_blank', {})['solutions'] = f"Number of solutions ({len(solutions_data)}) must match the number of blanks ({blank_count}) in the sentence."
                    else:
                        # Validate individual solution objects
                        frontend_word_temp_ids = set()
                        question_temp_id = self.context.get('temp_id') # Get from QuizSerializer context
                        if question_temp_id and isinstance(words_data, list):
                            frontend_word_temp_ids = {f"item_{question_temp_id}_{i}" for i in range(len(words_data))}

                        for idx, sol_obj in enumerate(solutions_data):
                             if not isinstance(sol_obj, dict) or 'slot_index' not in sol_obj or 'correct_word' not in sol_obj:
                                 errors.setdefault('fill_blank', {}).setdefault('solutions', []).append(f"Solution at index {idx} must be an object with 'slot_index' and 'correct_word'.")
                             elif sol_obj.get('slot_index') != idx: # Ensure slot_index is sequential and 0-based
                                 errors.setdefault('fill_blank', {}).setdefault('solutions', []).append(f"Solution at index {idx} has incorrect 'slot_index' {sol_obj.get('slot_index')}, expected {idx}.")
                             elif not sol_obj.get('correct_word'): # Ensure a correct_word (frontend temp ID) is provided
                                 errors.setdefault('fill_blank', {}).setdefault('solutions', []).append(f"Solution at index {idx} is missing the 'correct_word' (frontend temporary item ID).")
                             elif frontend_word_temp_ids and sol_obj.get('correct_word') not in frontend_word_temp_ids:
                                 # This check ensures the 'correct_word' ID corresponds to one of the words defined for this question
                                 errors.setdefault('fill_blank', {}).setdefault('solutions', []).append(f"Solution at index {idx} has an invalid 'correct_word' ID: '{sol_obj.get('correct_word')}' (not found in provided words for this question).")


        # --- Raise errors if any were found ---
        if errors:
            raise serializers.ValidationError(errors)

        # --- Clean up unused fields based on type (applied after validation) ---
        if question_type not in ['mcq', 'multi']:
             data['option1'], data['option2'], data['option3'], data['option4'] = None, None, None, None
             data['correct_option'] = None
             # Consider clearing media fields carefully, especially on update if they are not File objects
        
        if question_type not in ['multi', 'sort']: # correct_options used by multi and sort
            data['correct_options'] = None
        
        if question_type != 'short':
             data['correct_answer'] = None
        
        if question_type != 'sort': # question_data used by sort
             data['question_data'] = None
        
        if question_type != 'dragdrop': # fill_blank is only for dragdrop input processing
            data['fill_blank'] = None
            
        return data # Return validated (and potentially cleaned) data

    def create(self, validated_data):
        """
        Create and return a new `Question` instance, given the validated data.
        'fill_blank' and 'temp_id' are popped as they are not direct model fields of Question.
        They are used by the QuizSerializer to handle related data or mapping.
        """
        validated_data.pop('fill_blank', None) # Remove before passing to Question.objects.create
        validated_data.pop('temp_id', None)    # Remove before passing to Question.objects.create
        return super().create(validated_data)

    def update(self, instance, validated_data):
        """
        Update and return an existing `Question` instance, given the validated data.
        'fill_blank' and 'temp_id' are popped for the same reasons as in create.
        """
        validated_data.pop('fill_blank', None) # Remove before passing to instance.save()
        validated_data.pop('temp_id', None)    # Remove before passing to instance.save()
        return super().update(instance, validated_data)

# --- Quiz Serializer ---
class QuizSerializer(serializers.ModelSerializer):
    questions = QuestionSerializer(many=True, required=False) # Allow empty list on create/update
    tags = TagSerializer(many=True, read_only=True)
    tag_names = serializers.ListField(
        child=serializers.CharField(max_length=100), write_only=True, required=False
    )
    created_by = serializers.CharField(source='created_by.username', read_only=True)
    subject = serializers.PrimaryKeyRelatedField(queryset=Subject.objects.all(), allow_null=True, required=False) # Made not required for flexibility
    course = serializers.PrimaryKeyRelatedField(queryset=Course.objects.all(), allow_null=True, required=False)  # Made not required

    class Meta:
        model = Quiz
        fields = [
            'id','title','content','lesson','subject','course','quiz_type',
            'permalink','created_by','created_at',
            'seo_title','seo_description','focus_keyword','canonical_url',
            'og_title','og_description','og_image','is_locked',
            'tags','tag_names', # Tag fields
            'questions'
        ]
        read_only_fields = [
            'id', 'permalink', 'created_by', 'created_at', 'is_locked', 'tags',
            'seo_title', 'seo_description', 'canonical_url', # SEO fields often auto-generated
            'og_title', 'og_description', 'og_image', # OG fields often auto-generated
        ]
        extra_kwargs = {
            'title': {'required': True, 'allow_blank': False},
            'subject': {'required': True}, # Subject is mandatory for a quiz
            'content': {'required': False, 'allow_blank': True}, # Optional main content
            'lesson': {'required': False, 'allow_null': True},
            'course': {'required': False, 'allow_null': True},
        }

    def _save_tags(self, quiz_instance, tag_names_list):
        """Helper to manage tags for a quiz instance."""
        quiz_instance.tags.clear() # Clear existing tags first
        for name in tag_names_list:
            name = name.strip() # Remove leading/trailing whitespace
            if name: # Ensure tag name is not empty
                tag, _ = Tag.objects.get_or_create(name=name) # Get or create tag
                quiz_instance.tags.add(tag) # Add tag to quiz

    def _save_dragdrop_data(self, question_instance, fill_blank_data_dict, frontend_question_temp_id):
        """
        Helper to save FillBlankQuestion, BlankWord, and BlankSolution models
        for a 'dragdrop' type question.
        """
        if not fill_blank_data_dict or not isinstance(fill_blank_data_dict, dict):
            # This should ideally be caught by QuestionSerializer.validate
            print(f"Error: Invalid or missing fill_blank_data for question {question_instance.id}")
            return

        try:
            # 1. Create or update the FillBlankQuestion instance (OneToOne with Question)
            fb_instance, created = FillBlankQuestion.objects.update_or_create(
                question=question_instance,
                defaults={'sentence': fill_blank_data_dict.get('sentence', '')}
            )

            # If updating, clear old words and solutions to ensure consistency with new data.
            # A more complex diffing logic could be used for partial updates of words/solutions.
            if not created:
                fb_instance.words.all().delete() # This will cascade delete BlankSolution via ForeignKey

            # 2. Create BlankWord instances from the 'words' list in fill_blank_data
            word_id_map = {} # Maps frontend temporary item ID to backend BlankWord.id
            words_list_from_frontend = fill_blank_data_dict.get('words', []) # e.g., [{'text':'word1'}, ...]
            if not isinstance(words_list_from_frontend, list):
                 raise TypeError("Expected 'words' in fill_blank_data to be a list.")

            for idx, word_obj in enumerate(words_list_from_frontend):
                if not isinstance(word_obj, dict) or 'text' not in word_obj:
                     raise TypeError(f"Invalid word object format at index {idx} in fill_blank_data.")
                
                word_instance = BlankWord.objects.create(fill_blank=fb_instance, text=word_obj['text'])
                
                # Map the frontend's temporary ID for this word to the new BlankWord's DB ID
                if frontend_question_temp_id: # Ensure the question's temp_id was passed
                    # This is the ID generated on the frontend (e.g., "item_questionTempId_wordIndex")
                    current_frontend_item_id = f"item_{frontend_question_temp_id}_{idx}"
                    word_id_map[current_frontend_item_id] = word_instance.id
                else:
                    # Log if temp_id is missing, as mapping will fail
                    print(f"Warning: Missing frontend_question_temp_id for question {question_instance.id}. Cannot accurately map drag-drop solutions.")

            # 3. Create BlankSolution instances using the mapped IDs
            solutions_list_from_frontend = fill_blank_data_dict.get('solutions', []) # e.g., [{'slot_index':0, 'correct_word':'item_..._0'}, ...]
            if not isinstance(solutions_list_from_frontend, list):
                raise TypeError("Expected 'solutions' in fill_blank_data to be a list.")

            for sol_obj in solutions_list_from_frontend:
                 if not isinstance(sol_obj, dict) or 'correct_word' not in sol_obj or 'slot_index' not in sol_obj:
                     raise TypeError("Invalid solution object format in fill_blank_data.")
                 
                 frontend_item_id_for_solution = sol_obj['correct_word'] # This is the frontend's temp item ID
                 correct_word_db_id = word_id_map.get(frontend_item_id_for_solution) # Look up the DB ID

                 if correct_word_db_id:
                     BlankSolution.objects.create(
                         fill_blank=fb_instance,
                         slot_index=sol_obj['slot_index'],
                         correct_word_id=correct_word_db_id # Use the actual DB ID of the BlankWord
                     )
                 else:
                     # Log a warning if a solution couldn't be mapped (e.g., temp_id mismatch or missing)
                     print(f"Warning: Could not map frontend item ID '{frontend_item_id_for_solution}' to a backend BlankWord ID for quiz {question_instance.quiz.id}, question {question_instance.id}, slot {sol_obj['slot_index']}.")
                     # Depending on requirements, you might want to raise an error here
                     # raise serializers.ValidationError(f"Invalid mapping for solution in slot {sol_obj['slot_index']}.")

        except (TypeError, KeyError, ValueError) as e:
             # Catch potential errors during processing of the fill_blank structure
             raise serializers.ValidationError(f"Error processing fill_blank data for question {question_instance.id}: {e}")


    @transaction.atomic # Ensure all database operations succeed or fail together
    def create(self, validated_data):
        questions_input_data = validated_data.pop('questions', []) # Extract questions data
        tag_names_input = validated_data.pop('tag_names', [])       # Extract tag names
        validated_data['created_by'] = self.context['request'].user # Set creator

        quiz = Quiz.objects.create(**validated_data) # Create the Quiz instance

        if tag_names_input: # Save tags if provided
            self._save_tags(quiz, tag_names_input)

        # Process each question from the input data
        for q_input_data in questions_input_data:
            serializer_context = self.context.copy()
            # Get the frontend's temporary ID for this question (used for mapping dragdrop items)
            frontend_q_temp_id = q_input_data.get('temp_id')
            if frontend_q_temp_id:
                 serializer_context['temp_id'] = frontend_q_temp_id # Pass to QuestionSerializer via context

            # Instantiate and validate the QuestionSerializer with the current question's data
            question_serializer = QuestionSerializer(data=q_input_data, context=serializer_context)
            question_serializer.is_valid(raise_exception=True)
            
            # The QuestionSerializer.create method will pop 'fill_blank' and 'temp_id'
            # before saving the Question model.
            question_instance = question_serializer.save(quiz=quiz)

            # After Question instance is saved, if it's a dragdrop type,
            # process the 'fill_blank' data that was validated by QuestionSerializer.
            if question_instance.question_type == 'dragdrop':
                # Get the validated 'fill_blank' data from the QuestionSerializer instance
                fill_blank_json_data = question_serializer.validated_data.get('fill_blank')
                if fill_blank_json_data:
                    self._save_dragdrop_data(question_instance, fill_blank_json_data, frontend_q_temp_id)
        return quiz

    @transaction.atomic # Ensure atomicity for updates as well
    def update(self, instance, validated_data):
        # Remove fields that should not be updated directly or are handled separately
        validated_data.pop('permalink', None) # Permalink is auto-generated and usually not changed
        validated_data.pop('created_by', None) # Creator should not change

        questions_input_data = validated_data.pop('questions', None) # None if not provided for update
        tag_names_input = validated_data.pop('tag_names', None)       # None if not provided

        # Update the Quiz instance with simple fields
        instance = super().update(instance, validated_data)

        # Update tags if tag_names were provided in the request
        if tag_names_input is not None: # Allows sending empty list to clear tags
            self._save_tags(instance, tag_names_input)

        # Handle updates to nested questions if questions_data was provided
        if questions_input_data is not None:
            existing_questions_map = {q.id: q for q in instance.questions.all()}
            processed_question_ids = set()

            for q_input_data in questions_input_data:
                question_db_id = q_input_data.get('id') # ID of existing question, or None for new
                question_model_instance = existing_questions_map.get(question_db_id) if question_db_id else None

                serializer_context = self.context.copy()
                frontend_q_temp_id = q_input_data.get('temp_id') # For new dragdrop questions during update
                if frontend_q_temp_id:
                     serializer_context['temp_id'] = frontend_q_temp_id

                question_serializer = QuestionSerializer(
                    instance=question_model_instance, # Existing instance or None (for create)
                    data=q_input_data,
                    partial=bool(question_model_instance), # Partial update if instance exists
                    context=serializer_context
                )
                question_serializer.is_valid(raise_exception=True)
                
                # QuestionSerializer.create/update will pop 'fill_blank' and 'temp_id'
                saved_question_instance = question_serializer.save(quiz=instance)
                processed_question_ids.add(saved_question_instance.id)

                # Handle drag & drop data for the updated/created question
                if saved_question_instance.question_type == 'dragdrop':
                    fill_blank_json_data = question_serializer.validated_data.get('fill_blank')
                    if fill_blank_json_data:
                        self._save_dragdrop_data(saved_question_instance, fill_blank_json_data, frontend_q_temp_id)
                # If question type changed FROM dragdrop, delete its old FillBlankQuestion structure
                elif question_model_instance and question_model_instance.question_type == 'dragdrop' and saved_question_instance.question_type != 'dragdrop':
                     FillBlankQuestion.objects.filter(question=saved_question_instance).delete()

            # Delete any questions that were previously associated but not included in this update
            ids_to_delete = set(existing_questions_map.keys()) - processed_question_ids
            if ids_to_delete:
                instance.questions.filter(id__in=ids_to_delete).delete()

        instance.refresh_from_db() # Refresh to get latest state from DB
        return instance
