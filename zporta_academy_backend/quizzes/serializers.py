# quizzes/serializers.py

from rest_framework import serializers
from django.db import transaction # Import transaction for atomic operations

from django.contrib.contenttypes.models import ContentType
from analytics.models import ActivityEvent


# Assuming Subject/Course models live in separate apps:
from subjects.models import Subject # Import Subject from the 'subjects' app
from courses.models import Course   # Import Course from the 'courses' app
from .models import Quiz, Question, FillBlankQuestion, BlankWord, BlankSolution
from tags.models     import Tag
from tags.serializers import TagSerializer

# --- Serializers for Drag & Drop Nested Data ---
class BlankWordSerializer(serializers.ModelSerializer):
    class Meta:
        model = BlankWord
        fields = ['id', 'text']

class BlankSolutionSerializer(serializers.ModelSerializer):
    # Make correct_word writable by accepting the ID of a BlankWord
    correct_word = serializers.PrimaryKeyRelatedField(queryset=BlankWord.objects.all())

    class Meta:
        model = BlankSolution
        fields = ['slot_index', 'correct_word']

class FillBlankSerializer(serializers.ModelSerializer):
    # These are read-only representations for output when reading a FillBlankQuestion
    words     = BlankWordSerializer(many=True, read_only=True)
    solutions = BlankSolutionSerializer(many=True, read_only=True) # Uses the above BlankSolutionSerializer

    class Meta:
        model  = FillBlankQuestion
        # Defines fields for reading the nested structure of a FillBlankQuestion
        fields = ['id', 'sentence', 'words', 'solutions']
        read_only_fields = ['id', 'words', 'solutions'] # Sentence can be part of input if needed

# --- Main Question Serializer ---
class QuestionSerializer(serializers.ModelSerializer):
    # Explicitly define fields that are conditionally required as not required here
    option1 = serializers.CharField(required=False, allow_blank=True, allow_null=True)
    option2 = serializers.CharField(required=False, allow_blank=True, allow_null=True)
    option3 = serializers.CharField(required=False, allow_blank=True, allow_null=True)
    option4 = serializers.CharField(required=False, allow_blank=True, allow_null=True)

    attempt_count = serializers.IntegerField(read_only=True)
    correct_count = serializers.IntegerField(read_only=True)
    wrong_count   = serializers.IntegerField(read_only=True)

    correct_option = serializers.IntegerField(required=False, allow_null=True) # For MCQ
    correct_options = serializers.JSONField(required=False, allow_null=True) # For Multi, Sort solution
    correct_answer = serializers.CharField(required=False, allow_blank=True, allow_null=True) # For Short Answer
    question_data = serializers.JSONField(required=False, allow_null=True) # For Sort items/zones

    # Media fields
    question_image = serializers.ImageField(required=False, allow_null=True, use_url=True)
    question_audio = serializers.FileField(required=False, allow_null=True, use_url=True)
    option1_image = serializers.ImageField(required=False, allow_null=True, use_url=True)
    option1_audio = serializers.FileField(required=False, allow_null=True, use_url=True)
    option2_image = serializers.ImageField(required=False, allow_null=True, use_url=True)
    option2_audio = serializers.FileField(required=False, allow_null=True, use_url=True)
    option3_image = serializers.ImageField(required=False, allow_null=True, use_url=True)
    option3_audio = serializers.FileField(required=False, allow_null=True, use_url=True)
    option4_image = serializers.ImageField(required=False, allow_null=True, use_url=True)
    option4_audio = serializers.FileField(required=False, allow_null=True, use_url=True)

    # --- Drag & Drop Handling ---
    # 'fill_blank' is for *incoming* JSON data when creating/updating dragdrop questions
    fill_blank = serializers.JSONField(write_only=True, required=False, allow_null=True)
    # '_fill_blank' is for *outgoing* nested representation using FillBlankSerializer
    # It sources its data from the 'fill_blank' OneToOneField on the Question model
    _fill_blank = FillBlankSerializer(source='fill_blank', read_only=True)

    # Read-only alt text fields (auto-generated by model's save method)
    question_image_alt = serializers.CharField(read_only=True)
    option1_image_alt = serializers.CharField(read_only=True)
    option2_image_alt = serializers.CharField(read_only=True)
    option3_image_alt = serializers.CharField(read_only=True)
    option4_image_alt = serializers.CharField(read_only=True)

    # Add temp_id for frontend mapping; it's write_only and not saved to the Question model directly.
    temp_id = serializers.CharField(write_only=True, required=False, allow_null=True)

    class Meta:
        model = Question
        fields = [
            'id', 'quiz', 'temp_id', # Added temp_id for processing
            'question_type',
            'question_text',
            'question_image', 'question_image_alt', 'question_audio',
            'allow_speech_to_text',

            # Options
            'option1', 'option1_image', 'option1_image_alt', 'option1_audio',
            'option2', 'option2_image', 'option2_image_alt', 'option2_audio',
            'option3', 'option3_image', 'option3_image_alt', 'option3_audio',
            'option4', 'option4_image', 'option4_image_alt', 'option4_audio',

            # Answers / Data based on question type
            'correct_option',  # For MCQ
            'correct_options', # For Multi-Select (list of option numbers), Sort (list of ordered strings)
            'correct_answer',  # For Short Answer
            'question_data',   # For Sort items (list of strings to be sorted)
            'fill_blank',      # Incoming JSON blob for dragdrop (write-only)
            '_fill_blank',     # Outgoing nested object for dragdrop (read-only, represents FillBlankQuestion)
            # Hints
            'hint1', 'hint2',
            'attempt_count', 'correct_count', 'wrong_count',
        ]
        # 'quiz' is typically set by the parent QuizSerializer.
        # '_fill_blank' is read-only as it's a representation of related models.
        # Alt text fields are generated by the model.
        read_only_fields = [
            'id', 'quiz', '_fill_blank',
            'question_image_alt', 'option1_image_alt', 'option2_image_alt',
            'option3_image_alt', 'option4_image_alt',
            'attempt_count', 'correct_count', 'wrong_count',
        ]

    def validate(self, data):
        """
        Perform validation based on question_type.
        'data' contains the fields submitted for this specific question.
        'self.instance' is the existing question object if this is an update.
        """
        question_type = data.get('question_type', getattr(self.instance, 'question_type', None))
        if not question_type:
             raise serializers.ValidationError({"question_type": "Question type is required."})

        errors = {} # Accumulate errors

        # --- Validation for MCQ (Single Correct Choice) ---
        if question_type == 'mcq':
            if not data.get('option1'): errors['option1'] = 'Option 1 text is required for MCQ.'
            if not data.get('option2'): errors['option2'] = 'Option 2 text is required for MCQ.'
            correct_option = data.get('correct_option')
            if correct_option is None:
                 errors['correct_option'] = 'A correct option (1-4) must be selected for MCQ.'
            elif not isinstance(correct_option, int) or correct_option not in [1, 2, 3, 4]:
                 errors['correct_option'] = 'Correct option must be 1, 2, 3, or 4.'
            elif not data.get(f"option{correct_option}"): # Check if selected option has text
                 errors.setdefault('correct_option', []).append(
                     f"The selected correct option ({correct_option}) does not have any text."
                 )

        # --- Validation for Multi (Multiple Correct Choices) ---
        elif question_type == 'multi':
            if not data.get('option1'): errors['option1'] = 'Option 1 text is required for Multi-Select.'
            if not data.get('option2'): errors['option2'] = 'Option 2 text is required for Multi-Select.'
            correct_options = data.get('correct_options') # Expects a list of numbers, e.g., [1, 3]
            if not correct_options or not isinstance(correct_options, list) or len(correct_options) == 0:
                errors['correct_options'] = 'At least one correct option must be selected as a list (e.g., [1, 3]) for Multi-Select.'
            else:
                invalid_options = []
                for opt_num in correct_options:
                    if not isinstance(opt_num, int) or opt_num not in [1, 2, 3, 4]:
                        invalid_options.append(f"Invalid option number: {opt_num}. Must be 1-4.")
                    elif not data.get(f"option{opt_num}"): # Check if selected option has text
                        invalid_options.append(f"Selected correct option {opt_num} does not have any text.")
                if invalid_options:
                     errors['correct_options'] = invalid_options

        # --- Validation for Short Answer ---
        elif question_type == 'short':
            allow_speech = data.get('allow_speech_to_text', getattr(self.instance, 'allow_speech_to_text', False))
            if not data.get('correct_answer') and not allow_speech:
                 errors['correct_answer'] = 'A correct text answer is required for Short Answer questions unless speech input is enabled.'

        # --- Validation for Word Sort ---
        elif question_type == 'sort':
             q_data = data.get('question_data', {}) # Expects {'items': ['word1', 'word2', ...]}
             items = q_data.get('items', []) if isinstance(q_data, dict) else []
             if not isinstance(items, list) or len(items) < 2:
                  errors.setdefault('question_data', {})['items'] = "At least two sortable 'items' (words/phrases) are required for Word Sort."
             
             # Solution for sort is stored in correct_options (list of strings in correct order)
             correct_opts_sort = data.get('correct_options')
             if not correct_opts_sort or not isinstance(correct_opts_sort, list):
                 errors['correct_options'] = "A correct order (list of strings) must be provided for Word Sort."
             elif len(correct_opts_sort) != len(items):
                 errors['correct_options'] = "The correct order list must contain the same number of items as 'question_data.items'."
             elif any(not isinstance(item, str) for item in correct_opts_sort):
                 errors['correct_options'] = "Correct order for Word Sort must be a list of strings."
             # Ensure all items in correct_options are present in question_data.items
             elif set(correct_opts_sort) != set(items):
                 errors['correct_options'] = "All items in the correct order must match the items defined in 'question_data.items'."


        # --- Validation for Drag and Drop ---
        elif question_type == 'dragdrop':
            fill_data = data.get('fill_blank') # Check the incoming JSON blob
            if not fill_data:
                errors['fill_blank'] = "fill_blank data (sentence, words, solutions) is required for Drag & Drop questions."
            elif not isinstance(fill_data, dict):
                errors['fill_blank'] = "fill_blank data must be a JSON object."
            else:
                sentence = fill_data.get('sentence')
                words_data = fill_data.get('words') # Expects [{'text': 'word1'}, {'text': 'word2'}]
                solutions_data = fill_data.get('solutions') # Expects [{'slot_index': 0, 'correct_word': 'item_tempId_0'}]

                if not sentence or not isinstance(sentence, str) or '*' not in sentence:
                    errors.setdefault('fill_blank', {})['sentence'] = "A sentence string with at least one '*' placeholder is required."
                
                if not words_data or not isinstance(words_data, list) or len(words_data) == 0:
                    errors.setdefault('fill_blank', {})['words'] = "At least one word object (e.g., {'text': 'word'}) is required in the 'words' list."
                else:
                    for idx, w_obj in enumerate(words_data):
                        if not isinstance(w_obj, dict) or 'text' not in w_obj or not w_obj['text']:
                             errors.setdefault('fill_blank', {}).setdefault('words', []).append(f"Word at index {idx} must be an object with a non-empty 'text' key.")

                if not solutions_data or not isinstance(solutions_data, list):
                     errors.setdefault('fill_blank', {})['solutions'] = "The 'solutions' list is required."
                else:
                    blank_count = sentence.count('*') if sentence and isinstance(sentence, str) else 0
                    if len(solutions_data) != blank_count:
                        errors.setdefault('fill_blank', {})['solutions'] = f"Number of solutions ({len(solutions_data)}) must match the number of blanks ({blank_count}) in the sentence."
                    else:
                        # Validate individual solution objects
                        frontend_word_temp_ids = set()
                        question_temp_id = self.context.get('temp_id') # Get from QuizSerializer context
                        if question_temp_id and isinstance(words_data, list):
                            frontend_word_temp_ids = {f"item_{question_temp_id}_{i}" for i in range(len(words_data))}

                        for idx, sol_obj in enumerate(solutions_data):
                             if not isinstance(sol_obj, dict) or 'slot_index' not in sol_obj or 'correct_word' not in sol_obj:
                                 errors.setdefault('fill_blank', {}).setdefault('solutions', []).append(f"Solution at index {idx} must be an object with 'slot_index' and 'correct_word'.")
                             elif sol_obj.get('slot_index') != idx: # Ensure slot_index is sequential and 0-based
                                 errors.setdefault('fill_blank', {}).setdefault('solutions', []).append(f"Solution at index {idx} has incorrect 'slot_index' {sol_obj.get('slot_index')}, expected {idx}.")
                             elif not sol_obj.get('correct_word'): # Ensure a correct_word (frontend temp ID) is provided
                                 errors.setdefault('fill_blank', {}).setdefault('solutions', []).append(f"Solution at index {idx} is missing the 'correct_word' (frontend temporary item ID).")
                             elif frontend_word_temp_ids and sol_obj.get('correct_word') not in frontend_word_temp_ids:
                                 # This check ensures the 'correct_word' ID corresponds to one of the words defined for this question
                                 errors.setdefault('fill_blank', {}).setdefault('solutions', []).append(f"Solution at index {idx} has an invalid 'correct_word' ID: '{sol_obj.get('correct_word')}' (not found in provided words for this question).")


        # --- Raise errors if any were found ---
        if errors:
            raise serializers.ValidationError(errors)

        # --- Clean up unused fields based on type (applied after validation) ---
        if question_type not in ['mcq', 'multi']:
             data['option1'], data['option2'], data['option3'], data['option4'] = None, None, None, None
             data['correct_option'] = None
             # Consider clearing media fields carefully, especially on update if they are not File objects
        
        if question_type not in ['multi', 'sort']: # correct_options used by multi and sort
            data['correct_options'] = None
        
        if question_type != 'short':
             data['correct_answer'] = None
        
        if question_type != 'sort': # question_data used by sort
             data['question_data'] = None
        
        if question_type != 'dragdrop': # fill_blank is only for dragdrop input processing
            data['fill_blank'] = None
            
        return data # Return validated (and potentially cleaned) data

    def create(self, validated_data):
        """
        Create and return a new `Question` instance, given the validated data.
        'fill_blank' and 'temp_id' are popped as they are not direct model fields of Question.
        They are used by the QuizSerializer to handle related data or mapping.
        """
        validated_data.pop('fill_blank', None) # Remove before passing to Question.objects.create
        validated_data.pop('temp_id', None)    # Remove before passing to Question.objects.create
        return super().create(validated_data)

    def update(self, instance, validated_data):
        """
        Update and return an existing `Question` instance, given the validated data.
        'fill_blank' and 'temp_id' are popped for the same reasons as in create.
        """
        validated_data.pop('fill_blank', None) # Remove before passing to instance.save()
        validated_data.pop('temp_id', None)    # Remove before passing to instance.save()
        return super().update(instance, validated_data)

# --- Quiz Serializer ---
class QuizSerializer(serializers.ModelSerializer):
    # ─────── Read-only fields (populated by the view's .annotate(...) call) ───────
    attempt_count = serializers.IntegerField(read_only=True)
    correct_count = serializers.IntegerField(read_only=True)
    wrong_count   = serializers.IntegerField(read_only=True)

    # Use a SerializerMethodField for questions so we can pick up any
    # "annotated_questions" attribute set on the Quiz instance by the view.
    questions = serializers.SerializerMethodField()

    tags = TagSerializer(many=True, read_only=True)
    tag_names = serializers.ListField(
        child=serializers.CharField(max_length=100),
        write_only=True,
        required=False
    )

    created_by = serializers.CharField(source='created_by.username', read_only=True)
    subject    = serializers.PrimaryKeyRelatedField(
                     queryset=Subject.objects.all(),
                     allow_null=True,
                     required=False
                  )
    course     = serializers.PrimaryKeyRelatedField(
                     queryset=Course.objects.all(),
                     allow_null=True,
                     required=False
                  )

    class Meta:
        model = Quiz
        fields = [
            'id',
            'title',
            'content',
            'lesson',
            'subject',
            'course',
            'quiz_type',
            'permalink',
            'created_by',
            'created_at',

            'seo_title',
            'seo_description',
            'focus_keyword',
            'canonical_url',
            'og_title',
            'og_description',
            'og_image',
            'is_locked',

            'tags',
            'tag_names',

            'questions',

            # These three come from the view's annotate(...) call, not from a database lookup in the serializer:
            'attempt_count',
            'correct_count',
            'wrong_count',
        ]
        read_only_fields = [
            'id',
            'permalink',
            'created_by',
            'created_at',
            'is_locked',
            'tags',
            'seo_title',
            'seo_description',
            'canonical_url',
            'og_title',
            'og_description',
            'og_image',

            'attempt_count',
            'correct_count',
            'wrong_count',
        ]
        extra_kwargs = {
            'title':   {'required': True, 'allow_blank': False},
            'subject': {'required': True},
            'content': {'required': False, 'allow_blank': True},
            'lesson':  {'required': False, 'allow_null': True},
            'course':  {'required': False, 'allow_null': True},
        }

    def get_questions(self, quiz_obj):
        """
        Return the annotated questions if present; otherwise fallback to quiz_obj.questions.all()
        """
        annotated = getattr(quiz_obj, 'annotated_questions', None)
        if annotated is not None:
            qs = annotated
        else:
            qs = quiz_obj.questions.all()

        return QuestionSerializer(qs, many=True, context=self.context).data

    # ─────── Internal helpers to manage tags & drag‐drop data ───────
    def _save_tags(self, quiz_instance, tag_names_list):
        quiz_instance.tags.clear()
        for name in tag_names_list:
            name = name.strip()
            if name:
                tag, _ = Tag.objects.get_or_create(name=name)
                quiz_instance.tags.add(tag)

    def _save_dragdrop_data(self, question_instance, fill_blank_data_dict, frontend_question_temp_id):
        if not fill_blank_data_dict or not isinstance(fill_blank_data_dict, dict):
            return

        try:
            fb_instance, created = FillBlankQuestion.objects.update_or_create(
                question=question_instance,
                defaults={'sentence': fill_blank_data_dict.get('sentence', '')}
            )
            if not created:
                fb_instance.words.all().delete()

            word_id_map = {}
            words_list_from_frontend = fill_blank_data_dict.get('words', [])
            if not isinstance(words_list_from_frontend, list):
                raise TypeError("Expected 'words' to be a list.")

            for idx, word_obj in enumerate(words_list_from_frontend):
                if not isinstance(word_obj, dict) or 'text' not in word_obj:
                    raise TypeError(f"Invalid word object format at index {idx}.")
                word_instance = BlankWord.objects.create(fill_blank=fb_instance, text=word_obj['text'])

                if frontend_question_temp_id:
                    frontend_id = f"item_{frontend_question_temp_id}_{idx}"
                    word_id_map[frontend_id] = word_instance.id

            solutions_list_from_frontend = fill_blank_data_dict.get('solutions', [])
            if not isinstance(solutions_list_from_frontend, list):
                raise TypeError("Expected 'solutions' to be a list.")

            for sol_obj in solutions_list_from_frontend:
                if not isinstance(sol_obj, dict) or 'correct_word' not in sol_obj or 'slot_index' not in sol_obj:
                    raise TypeError("Invalid solution object format.")
                frontend_item_id = sol_obj['correct_word']
                correct_db_id = word_id_map.get(frontend_item_id)
                if correct_db_id:
                    BlankSolution.objects.create(
                        fill_blank=fb_instance,
                        slot_index=sol_obj['slot_index'],
                        correct_word_id=correct_db_id
                    )
                else:
                    print(f"Warning: Could not map '{frontend_item_id}' for question {question_instance.id}.")

        except (TypeError, KeyError, ValueError) as e:
            raise serializers.ValidationError(f"Error processing fill_blank for question {question_instance.id}: {e}")


    @transaction.atomic
    def create(self, validated_data):
        questions_input_data = validated_data.pop('questions', [])
        tag_names_input = validated_data.pop('tag_names', [])
        validated_data['created_by'] = self.context['request'].user

        quiz = Quiz.objects.create(**validated_data)

        if tag_names_input:
            self._save_tags(quiz, tag_names_input)

        for q_input_data in questions_input_data:
            serializer_context = self.context.copy()
            frontend_q_temp_id = q_input_data.get('temp_id')
            if frontend_q_temp_id:
                serializer_context['temp_id'] = frontend_q_temp_id

            question_serializer = QuestionSerializer(data=q_input_data, context=serializer_context)
            question_serializer.is_valid(raise_exception=True)
            question_instance = question_serializer.save(quiz=quiz)

            if question_instance.question_type == 'dragdrop':
                fill_blank_json = question_serializer.validated_data.get('fill_blank')
                if fill_blank_json:
                    self._save_dragdrop_data(question_instance, fill_blank_json, frontend_q_temp_id)

        return quiz

    @transaction.atomic
    def update(self, instance, validated_data):
        validated_data.pop('permalink', None)
        validated_data.pop('created_by', None)

        questions_input_data = validated_data.pop('questions', None)
        tag_names_input = validated_data.pop('tag_names', None)

        instance = super().update(instance, validated_data)

        if tag_names_input is not None:
            self._save_tags(instance, tag_names_input)

        if questions_input_data is not None:
            existing_map = {q.id: q for q in instance.questions.all()}
            processed_ids = set()

            for q_input_data in questions_input_data:
                question_db_id = q_input_data.get('id')
                question_model_instance = existing_map.get(question_db_id) if question_db_id else None

                serializer_context = self.context.copy()
                frontend_q_temp_id = q_input_data.get('temp_id')
                if frontend_q_temp_id:
                    serializer_context['temp_id'] = frontend_q_temp_id

                question_serializer = QuestionSerializer(
                    instance=question_model_instance,
                    data=q_input_data,
                    partial=bool(question_model_instance),
                    context=serializer_context
                )
                question_serializer.is_valid(raise_exception=True)
                saved_q = question_serializer.save(quiz=instance)
                processed_ids.add(saved_q.id)

                if saved_q.question_type == 'dragdrop':
                    fill_blank_json = question_serializer.validated_data.get('fill_blank')
                    if fill_blank_json:
                        self._save_dragdrop_data(saved_q, fill_blank_json, frontend_q_temp_id)
                elif question_model_instance and question_model_instance.question_type == 'dragdrop' and saved_q.question_type != 'dragdrop':
                    FillBlankQuestion.objects.filter(question=saved_q).delete()

            ids_to_delete = set(existing_map.keys()) - processed_ids
            if ids_to_delete:
                instance.questions.filter(id__in=ids_to_delete).delete()

        instance.refresh_from_db()
        return instance